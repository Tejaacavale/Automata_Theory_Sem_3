      -------------------------------------------------------------------------------
ASSUMPTIONS:
1. Negetive numbers arent handled for question 2.
2. Real Numbers will be considered as y in the grammar of question 2 and not r
3. brackets , semicolon , colon is not accepted
4. all the operator are generalised to a letter "o" for conveince
      ---------------------------------------------------------------------------------
EXPLANATION OF SOLUTION:
The tokenised input string is converted to variables acording to the language in the CNF form.
The below is the grammar in the CNF Form
T=["y","if","else","o"]
NT=["S","I","A","T","C","P","Q","R","E","O","X"]
CNF ={
    "S":['IA',"TT","y"],
    "T":['IA',"TT","y"],
    "A":["CT","PQ"],
    "P":["CT"],
    "Q":["ET"],
    "E":["else"],
    "I":["if"],
    "C":["XR","y"],
    "R":["OX"],
    "O":["o"],
    "X":["y","OX","XR"]
}
Now for any given input , we use the CYK(Cocke–Younger–Kasami) Algorithm.The CYK algorithm is a bottom-up parsing algorithm based on dynamic programming, typically used in parsing context-free grammars. It constructs a table DP of size n x n to determine if a given input string w can be generated by a context-free grammar G. It starts by checking for single-character productions and then builds up to longer substrings, filling the table according to the production rules of G. If the start symbol S appears in the top-left cell (1, n) of the table, the algorithm accepts the string, indicating it can be derived from the grammar; otherwise, it rejects the string as not derivable. This algorithm essentially performs bottom-up parsing by breaking down the input string into smaller substrings and checking if they can be generated by the grammar rules.


